<?xml version="1.0"?>
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.3//EN"
               "http://www.oasis-open.org/docbook/xml/4.3/docbookx.dtd"
[
  <!ENTITY % local.common.attrib "xmlns:xi  CDATA  #FIXED 'http://www.w3.org/2003/XInclude'">
  <!ENTITY version SYSTEM "version.xml">
]>
<book id="index">
  <bookinfo>
    <title>CTPL Reference Manual</title>
    <releaseinfo>
      for CTPL &version;
      The latest version of this documentation can be found on-line at
      <ulink role="online-location" url="http://ctpl.tuxfamily.org/doc/unstable/index.html">http://ctpl.tuxfamily.org/doc/unstable/</ulink>.
    </releaseinfo>
  </bookinfo>

  <chapter>
    <title>CTPL overview</title>
    
    <section>
      <title>Introduction</title>
      <para>
        CTPL is a template library written in C. It allows fast and easy parsing
        of templates from many sources (including in-memory data and local and
        remote streaming, thanks to GIO) and fine control over template parsing
        environment.
      </para>
      <para>
        CTPL depends on the following libraries:
        <variablelist>
          <varlistentry>
            <term><ulink url="http://library.gnome.org/devel/glib/">GLib</ulink></term>
            <listitem>
              <para>
                General purpose C utility library
              </para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term><ulink url="http://library.gnome.org/devel/gio/">GIO</ulink></term>
            <listitem>
              <para>
                GLib's I/O abstraction library
              </para>
            </listitem>
          </varlistentry>
        </variablelist>
      </para>
      
      <section>
        <title>Advantages and disadvantages</title>
        
        <section>
          <title>Advantages</title>
          <itemizedlist>
            <listitem>
              <para>
                It is a library, then it can be easily used from programs;
              </para>
            </listitem>
            <listitem>
              <para>
                <link linkend="working-design">Separated lexer and parser</link>;
              </para>
            </listitem>
            <listitem>
              <para>
                It is written in portable C;
              </para>
            </listitem>
            <listitem>
              <para>
                Simple syntax;
              </para>
            </listitem>
            <listitem>
              <para>
                Fast and strict parsing;
              </para>
            </listitem>
            <listitem>
              <para>
                Possible in-memory parsing, allowing non-file data parsing and
                avoiding I/O-latency, through GIO's
                <link linkend="GMemoryInputStream">GMemoryInputStream</link> and
                <link linkend="GMemoryOutputStream">GMemoryOutputStream</link>.
              </para>
            </listitem>
          </itemizedlist>
        </section>
        
        <section>
          <title>Disadvantages</title>
          <itemizedlist>
            <listitem>
              <para>
                Since the input is first completely load as a token tree in
                memory - which is also one of the advantages - , it consumes a
                little more memory than the input template.
              </para>
            </listitem>
          </itemizedlist>
        </section>
      </section>
    </section>
    
    <section>
      <title id="working-design">Working design</title>
      <para>
        The CTPL engine is split, as most parsers, in two distinct parts:
        the lexer and the parser.
      </para>
      <section>
        <title>The lexer</title>
        <para>
          The <link linkend="ctpl-CtplLexer">lexer</link> is the part that reads
          the actual input data, and tries to create a
          <link linkend="ctpl-CtplToken">token</link> tree (internal
          representation of the input) that the
          <link linkend="ctpl-CtplParser">parser</link> will use.
        </para>
      </section>
      <section>
        <title>The parser</title>
        <para>
          The parser reads a <link linkend="ctpl-CtplToken">token</link> tree
          and an <link linkend="ctpl-CtplEnviron">environment</link>, and
          outputs the computed template.
        </para>
      </section>
      <para>
        By exposing this separation of the tasks to the user, it is possible
        to <link linkend="ctpl-CtplParser">parse</link> a single template many
        times with a different environment without needing to
        re-<link linkend="ctpl-CtplLexer">lex</link> it, which will save
        computation time and resources.
      </para>
      <example>
        <title>Using the library to lex and parse a template</title>
        <programlisting>
#include &lt;ctpl/ctpl.h&gt;

/**
 * procede_template:
 * @input:  The input stream
 * @env:    The environment against which parse the input.
 * @output: The output stream
 * @error:  Return location for an error, or %NULL to ignore them.
 * 
 * Parses and lexes a template.
 * 
 * Returns: %TRUE on success, %FALSE on error.
 */
gboolean
procede_template (CtplInputStream  *input,
                  CtplEnviron      *env,
                  CtplOutputStream *output,
                  GError          **error)
{
  gboolean    success = FALSE;
  CtplToken  *tree;
  
  /* first, create a token tree from the input template */
  tree = ctpl_lexer_lex (input, error);
  if (tree != NULL) {
    /* then, parse this tree against the environment */
    success = ctpl_parser_parse (tree, env, output, error);
  }
  /* free the built tree */
  ctpl_lexer_free_tree (tree);
  
  return success;
}
        </programlisting>
      </example>
    </section>
    
    <section>
      <title>Syntax</title>
      <para>
        CTPL supports 2 kind of data:
        <variablelist>
          <varlistentry>
            <term><link linkend="raw-data">Raw data</link></term>
            <listitem>
              <para>
                The actual content of your template, or at least most of it:
                unparsed data that will remain (almost) unchanged.
              </para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term><link linkend="template-blocks">Template blocks</link></term>
            <listitem>
              <para>
                The instructions that makes the template engine useful.
              </para>
            </listitem>
          </varlistentry>
        </variablelist>
      </para>
      <section id="raw-data">
        <title>Raw data</title>
        <para>
          There is no syntax for the raw data: everything that is not a
          template block is raw data. The only exception to this rule is that
          the template-blocks-delimiters <code>{</code> and <code>}</code>
          must be escaped using a backslash (<code>\</code>), as well as
          backslashes themselves. For example, to produce an opening bracket,
          you need to write <code>\{</code>, and to produce a backslash you need
          to write it twice: <code>\\</code> (the first one escapes the second).
        </para>
        <note>
          <para>
            Even if escaping a character that doesn't need to be escaped works
            perfectly (thought the escaping backslash doesn't appear), it is
            recommended not to do so in order to allow future addition of new
            escaping sequences without changes on your template's output.
          </para>
        </note>
      </section>
      <section id="template-blocks">
        <title>Template blocks</title>
        <para>
          Template blocks are delimited with brackets: they are opened with an
          unescaped opening bracket (<code>{</code>) and closed with an
          unescaped closing bracket (<code>}</code>). All data inside these two
          brackets is template instructions.
        </para>
        <para>
          There is 3 instruction types:
          <variablelist>
            <varlistentry>
              <term>The <code>for</code> loop</term>
              <listitem>
                <para>
                  The <code>for</code> loop allows to iterate over an array from
                  the environment, and computes the loop body for each element
                  in the array.
                </para>
                <para>
                  The syntax is the following:
                  <informalexample>
                    <programlisting>
{for &lt;iterator&gt; in &lt;array&gt;}&lt;loop body&gt;{end}
                    </programlisting>
                  </informalexample>
                  <code>iterator</code> is the variable name referring to
                  the current array's element;
                  <code>array</code> is the array over which iterate, as named
                  in the environment;
                  <code>loop body</code> is the data that will be evaluated on
                  each iteration of the loop, and may contain any elements
                  (raw data or instructions).
                </para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>The <code>if</code> switch</term>
              <listitem>
                <para>
                  The <code>if</code> block is a conditional branching.
                </para>
                <para>
                  The syntax is the following:
                  <informalexample>
                    <programlisting>
{if &lt;expression&gt;}&lt;if body&gt;[{else}&lt;else body&gt;]{end}
                    </programlisting>
                  </informalexample>
                  <code>expression</code> is an expression (see below) that will
                  be evaluated to a boolean value,
                  <code>TRUE</code> or <code>FALSE</code>.
                </para>
                <para>
                  If the <code>expression</code> evaluates to <code>TRUE</code>,
                  the <code>if body</code> will be parsed.
                  If the <code>expression</code> evaluates to <code>FALSE</code>,
                  the <code>else body</code> will be parsed if any, or nothing
                  will be done if the <code>else</code> is missing.
                </para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>An expression</term>
              <listitem>
                <para>
                  An expression that will be replaced by its computation result.
                </para>
                <para>
                  See <link linkend="ctpl-CtplLexerExpr">CtplLexerExpr</link>
                  for details on the syntax of expressions. Basically, it may be
                  any mathematical-like expression that may include reference(s)
                  to variable(s).
                </para>
              </listitem>
            </varlistentry>
          </variablelist>
        </para>
      </section>
      
      <section>
        <title>Examples</title>
        <example>
          <title>Short template</title>
          <para>
            <informalexample>
              <programlisting>
{for i in array}
  {i}
{end}
              </programlisting>
            </informalexample>
            This example will output each item of <code>array</code> on a
            newline. Supposing the array <code>[1, 2, 3]</code>, the output will
            be:
            <informalexample>
              <programlisting>

&nbsp;&nbsp;1

&nbsp;&nbsp;2

&nbsp;&nbsp;3

              </programlisting>
            </informalexample>
          </para>
        </example>
        
        <example>
          <title>Longer template</title>
          <para>
            Here what may be a template for a member list HTML page:
            <informalexample>
              <programlisting>
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;Member list&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;h1&gt;List of our members&lt;h1&gt;
    &lt;ul class="memberlist"&gt;
    {for member in members}
      &lt;li&gt;{member}&lt;/li&gt;
    {end}
    &lt;/ul&gt;
  &lt;/body&gt;
&lt;/html&gt;
              </programlisting>
            </informalexample>
          </para>
        </example>
      </section>
    </section>
  </chapter>

  <chapter>
    <title>API reference</title>
    <xi:include href="xml/value.xml"/>
    <xi:include href="xml/environ.xml"/>
    <xi:include href="xml/token.xml"/>
    <xi:include href="xml/lexer.xml"/>
    <xi:include href="xml/lexer-expr.xml"/>
    <xi:include href="xml/parser.xml"/>
    <xi:include href="xml/eval.xml"/>
    <xi:include href="xml/io.xml"/>
    <xi:include href="xml/input-stream.xml"/>
    <xi:include href="xml/output-stream.xml"/>
  </chapter>
  <chapter>
    <title>Private API reference</title>
    <para>
      This is the private API used to implement CTPL and accessible only from
      inside the library. It makes sense only when hacking CTPL.
    </para>
    <xi:include href="xml/stack.xml"/>
    <xi:include href="xml/mathutils.xml"/>
  </chapter>
  <!--chapter id="object-tree">
    <title>Object Hierarchy</title>
     <xi:include href="xml/tree_index.sgml"/>
  </chapter-->
  <index id="api-index-full">
    <title>API Index</title>
    <xi:include href="xml/api-index-full.xml"><xi:fallback /></xi:include>
  </index>

  <xi:include href="xml/annotation-glossary.xml"><xi:fallback /></xi:include>
</book>
